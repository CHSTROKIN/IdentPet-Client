{"version":3,"sources":["useOffsetX.ts"],"names":["Extrapolate","interpolate","useDerivedValue","useOffsetX","opts","visibleRanges","handlerOffset","index","size","loop","dataLength","type","viewCount","_viewCount","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","Math","round","positiveCount","startPos","MAX","MIN","x","negativeRange","positiveRange","value","Number","MAX_SAFE_INTEGER","inputRange","MIN_VALUE","outputRange","CLAMP"],"mappings":"AACA,SACEA,WADF,EAEEC,WAFF,EAGEC,eAHF,QAIO,yBAJP;AAkBA,OAAO,MAAMC,UAAU,GAAG,CAACC,IAAD,EAAcC,aAAd,KAAgD;AACxE,QAAM;AACJC,IAAAA,aADI;AAEJC,IAAAA,KAFI;AAGJC,IAAAA,IAHI;AAIJC,IAAAA,IAJI;AAKJC,IAAAA,UALI;AAMJC,IAAAA,IAAI,GAAG,UANH;AAOJC,IAAAA,SAAS,EAAEC;AAPP,MAQFT,IARJ;AAUA,QAAMU,WAAW,GAAGJ,UAApB;AACA,QAAMK,YAAY,GAAGD,WAAW,GAAG,CAAnC;AACA,QAAME,WAAW,GAAGR,IAAI,GAAGM,WAA3B;AACA,QAAMG,UAAU,GAAG,MAAMT,IAAzB;AAEA,QAAMI,SAAS,GAAGC,UAAH,aAAGA,UAAH,cAAGA,UAAH,GAAiBK,IAAI,CAACC,KAAL,CAAW,CAACL,WAAW,GAAG,CAAf,IAAoB,CAA/B,CAAhC;AACA,QAAMM,aAAa,GACXT,IAAI,KAAK,UAAT,GAAsBC,SAAtB,GAAkCG,YAAY,GAAGH,SADzD;AAGA,MAAIS,QAAQ,GAAGb,IAAI,GAAGD,KAAtB;AACA,MAAIA,KAAK,GAAGa,aAAZ,EACEC,QAAQ,GAAG,CAACd,KAAK,GAAGO,WAAT,IAAwBN,IAAnC;AAEF,QAAMc,GAAG,GAAGF,aAAa,GAAGZ,IAA5B;AACA,QAAMe,GAAG,GAAG,EAAE,CAACR,YAAY,GAAGK,aAAhB,IAAiCZ,IAAnC,CAAZ;AAEA,QAAMgB,CAAC,GAAGtB,eAAe,CAAC,MAAM;AAC9B,UAAM;AAAEuB,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,QAAmCrB,aAAa,CAACsB,KAAvD;AACA,QACE,CAACpB,KAAK,GAAGkB,aAAa,CAAC,CAAD,CAArB,IAA4BlB,KAAK,GAAGkB,aAAa,CAAC,CAAD,CAAlD,MACUlB,KAAK,GAAGmB,aAAa,CAAC,CAAD,CAArB,IAA4BnB,KAAK,GAAGmB,aAAa,CAAC,CAAD,CAD3D,CADF,EAIE,OAAOE,MAAM,CAACC,gBAAd;;AAEF,QAAIpB,IAAJ,EAAU;AACR,YAAMqB,UAAU,GAAG,CACjB,CAACd,WADgB,EAEjBO,GAAG,GAAGN,UAAN,GAAmBI,QAAnB,GAA8BO,MAAM,CAACG,SAFpB,EAGjBR,GAAG,GAAGN,UAAN,GAAmBI,QAHF,EAIjB,CAJiB,EAKjBC,GAAG,GAAGL,UAAN,GAAmBI,QALF,EAMjBC,GAAG,GAAGL,UAAN,GAAmBI,QAAnB,GAA8BO,MAAM,CAACG,SANpB,EAOjBf,WAPiB,CAAnB;AAUA,YAAMgB,WAAW,GAAG,CAClBX,QADkB,EAElBC,GAAG,GAAGL,UAAN,GAAmBW,MAAM,CAACG,SAFR,EAGlBR,GAAG,GAAGN,UAHY,EAIlBI,QAJkB,EAKlBC,GAAG,GAAGL,UALY,EAMlBM,GAAG,GAAGN,UAAN,GAAmBW,MAAM,CAACG,SANR,EAOlBV,QAPkB,CAApB;AAUA,aAAOpB,WAAW,CAChBK,aAAa,CAACqB,KADE,EAEhBG,UAFgB,EAGhBE,WAHgB,EAIhBhC,WAAW,CAACiC,KAJI,CAAlB;AAMD;;AAED,WAAO3B,aAAa,CAACqB,KAAd,GAAsBnB,IAAI,GAAGD,KAApC;AACD,GAtCwB,EAsCtB,CAACE,IAAD,EAAOC,UAAP,EAAmBE,SAAnB,EAA8BD,IAA9B,EAAoCH,IAApC,EAA0CH,aAA1C,CAtCsB,CAAzB;AAwCA,SAAOmB,CAAP;AACD,CApEM","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport {\n  Extrapolate,\n  interpolate,\n  useDerivedValue,\n} from \"react-native-reanimated\";\n\nimport type { IVisibleRanges } from \"./useVisibleRanges\";\n\nexport interface IOpts {\n  index: number\n  size: number\n  handlerOffset: Animated.SharedValue<number>\n  dataLength: number\n  type?: \"positive\" | \"negative\"\n  viewCount?: number\n  loop?: boolean\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n  const {\n    handlerOffset,\n    index,\n    size,\n    loop,\n    dataLength,\n    type = \"positive\",\n    viewCount: _viewCount,\n  } = opts;\n\n  const ITEM_LENGTH = dataLength;\n  const VALID_LENGTH = ITEM_LENGTH - 1;\n  const TOTAL_WIDTH = size * ITEM_LENGTH;\n  const HALF_WIDTH = 0.5 * size;\n\n  const viewCount = _viewCount ?? Math.round((ITEM_LENGTH - 1) / 2);\n  const positiveCount\n        = type === \"positive\" ? viewCount : VALID_LENGTH - viewCount;\n\n  let startPos = size * index;\n  if (index > positiveCount)\n    startPos = (index - ITEM_LENGTH) * size;\n\n  const MAX = positiveCount * size;\n  const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n  const x = useDerivedValue(() => {\n    const { negativeRange, positiveRange } = visibleRanges.value;\n    if (\n      (index < negativeRange[0] || index > negativeRange[1])\n            && (index < positiveRange[0] || index > positiveRange[1])\n    )\n      return Number.MAX_SAFE_INTEGER;\n\n    if (loop) {\n      const inputRange = [\n        -TOTAL_WIDTH,\n        MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n        MIN - HALF_WIDTH - startPos,\n        0,\n        MAX + HALF_WIDTH - startPos,\n        MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n        TOTAL_WIDTH,\n      ];\n\n      const outputRange = [\n        startPos,\n        MAX + HALF_WIDTH - Number.MIN_VALUE,\n        MIN - HALF_WIDTH,\n        startPos,\n        MAX + HALF_WIDTH,\n        MIN - HALF_WIDTH + Number.MIN_VALUE,\n        startPos,\n      ];\n\n      return interpolate(\n        handlerOffset.value,\n        inputRange,\n        outputRange,\n        Extrapolate.CLAMP,\n      );\n    }\n\n    return handlerOffset.value + size * index;\n  }, [loop, dataLength, viewCount, type, size, visibleRanges]);\n\n  return x;\n};\n"]}