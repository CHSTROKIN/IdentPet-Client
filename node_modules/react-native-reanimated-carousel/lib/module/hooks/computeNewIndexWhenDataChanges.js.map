{"version":3,"sources":["computeNewIndexWhenDataChanges.ts"],"names":["omitZero","a","b","computeNewIndexWhenDataChanges","params","direction","handlerOffset","_handlerOffset","size","previousLength","currentLength","positionIndex","round","isPositive","Math","abs","parseInt","String","prevOffset","prevIndex","changedLength","changedOffset"],"mappings":"AAAA,OAAO,SAASA,QAAT,CAAkBC,CAAlB,EAA6BC,CAA7B,EAAwC;AAC7C;;AACA,MAAID,CAAC,KAAK,CAAV,EACE,OAAO,CAAP;AAEF,SAAOC,CAAP;AACD;AAED,OAAO,SAASC,8BAAT,CAAwCC,MAAxC,EAMJ;AACD;;AACA,QAAM;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,aAAa,EAAEC,cAA5B;AAA4CC,IAAAA,IAA5C;AAAkDC,IAAAA,cAAlD;AAAkEC,IAAAA;AAAlE,MAAoFN,MAA1F;AAEA,MAAIE,aAAa,GAAGC,cAApB;AACA,MAAII,aAAJ;AACA,MAAIC,KAAJ;AAEA,QAAMC,UAAU,GAAGR,SAAS,GAAG,CAA/B;;AAEA,MAAIQ,UAAJ,EAAgB;AACdF,IAAAA,aAAa,GAAIG,IAAI,CAACC,GAAL,CAAST,aAAT,CAAD,GAA4BE,IAA5C;AACAI,IAAAA,KAAK,GAAGI,QAAQ,CAACC,MAAM,CAACjB,QAAQ,CAACS,cAAD,EAAiBE,aAAa,GAAGF,cAAjC,CAAT,CAAP,CAAhB;AACD,GAHD,MAIK;AACHE,IAAAA,aAAa,GAAG,CAACG,IAAI,CAACC,GAAL,CAAST,aAAT,IAA0BE,IAA3B,IAAmCA,IAAnD;AACAI,IAAAA,KAAK,GAAGI,QAAQ,CAACC,MAAM,CAACjB,QAAQ,CAACS,cAAD,EAAiBE,aAAa,GAAGF,cAAjC,CAAT,CAAP,CAAR,GAA6E,CAArF;AACD;;AAED,QAAMS,UAAU,GAAGlB,QAAQ,CAACS,cAAD,EAAiBE,aAAa,GAAGF,cAAjC,CAA3B;AACA,QAAMU,SAAS,GAAGN,UAAU,GAAGK,UAAH,GAAgBT,cAAc,GAAGS,UAAjB,GAA8B,CAA1E;AACA,QAAME,aAAa,GAAGR,KAAK,IAAIF,aAAa,GAAGD,cAApB,CAA3B;AACA,QAAMY,aAAa,GAAGD,aAAa,GAAGZ,IAAtC;;AACA,MAAIW,SAAS,GAAGT,aAAa,GAAG,CAA5B,IAAiCA,aAAa,GAAGD,cAArD,EAAqE;AACnE,QAAII,UAAJ,EACEP,aAAa,GAAG,CAACI,aAAa,GAAG,CAAjB,IAAsBF,IAAtB,GAA6BH,SAA7C,CADF,KAIEC,aAAa,GAAG,CAACI,aAAa,GAAG,CAAjB,IAAsBF,IAAtB,GAA6B,CAAC,CAA9C;AACH,GAND,MAOK;AACHF,IAAAA,aAAa,IAAIe,aAAa,GAAGhB,SAAjC;AACD;;AAED,SAAOC,aAAP;AACD","sourcesContent":["export function omitZero(a: number, b: number) {\n  \"worklet\";\n  if (a === 0)\n    return 0;\n\n  return b;\n}\n\nexport function computeNewIndexWhenDataChanges(params: {\n  direction: number\n  handlerOffset: number\n  size: number\n  previousLength: number\n  currentLength: number\n}) {\n  \"worklet\";\n  const { direction, handlerOffset: _handlerOffset, size, previousLength, currentLength } = params;\n\n  let handlerOffset = _handlerOffset;\n  let positionIndex;\n  let round;\n\n  const isPositive = direction < 0;\n\n  if (isPositive) {\n    positionIndex = (Math.abs(handlerOffset)) / size;\n    round = parseInt(String(omitZero(previousLength, positionIndex / previousLength)));\n  }\n  else {\n    positionIndex = (Math.abs(handlerOffset) - size) / size;\n    round = parseInt(String(omitZero(previousLength, positionIndex / previousLength))) + 1;\n  }\n\n  const prevOffset = omitZero(previousLength, positionIndex % previousLength);\n  const prevIndex = isPositive ? prevOffset : previousLength - prevOffset - 1;\n  const changedLength = round * (currentLength - previousLength);\n  const changedOffset = changedLength * size;\n  if (prevIndex > currentLength - 1 && currentLength < previousLength) {\n    if (isPositive)\n      handlerOffset = (currentLength - 1) * size * direction;\n\n    else\n      handlerOffset = (currentLength - 1) * size * -1;\n  }\n  else {\n    handlerOffset += changedOffset * direction;\n  }\n\n  return handlerOffset;\n}\n\n"]}