{"version":3,"sources":["useOffsetX.ts"],"names":["useOffsetX","opts","visibleRanges","handlerOffset","index","size","loop","dataLength","type","_viewCount","viewCount","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","Math","round","positiveCount","startPos","MAX","MIN","x","value","negativeRange","positiveRange","Number","MAX_SAFE_INTEGER","inputRange","MIN_VALUE","outputRange","Extrapolate","CLAMP","interpolate"],"mappings":"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","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport {\n  Extrapolate,\n  interpolate,\n  useDerivedValue,\n} from \"react-native-reanimated\";\n\nimport type { IVisibleRanges } from \"./useVisibleRanges\";\n\nexport interface IOpts {\n  index: number\n  size: number\n  handlerOffset: Animated.SharedValue<number>\n  dataLength: number\n  type?: \"positive\" | \"negative\"\n  viewCount?: number\n  loop?: boolean\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n  const {\n    handlerOffset,\n    index,\n    size,\n    loop,\n    dataLength,\n    type = \"positive\",\n    viewCount: _viewCount,\n  } = opts;\n\n  const ITEM_LENGTH = dataLength;\n  const VALID_LENGTH = ITEM_LENGTH - 1;\n  const TOTAL_WIDTH = size * ITEM_LENGTH;\n  const HALF_WIDTH = 0.5 * size;\n\n  const viewCount = _viewCount ?? Math.round((ITEM_LENGTH - 1) / 2);\n  const positiveCount\n        = type === \"positive\" ? viewCount : VALID_LENGTH - viewCount;\n\n  let startPos = size * index;\n  if (index > positiveCount)\n    startPos = (index - ITEM_LENGTH) * size;\n\n  const MAX = positiveCount * size;\n  const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n  const x = useDerivedValue(() => {\n    const { negativeRange, positiveRange } = visibleRanges.value;\n    if (\n      (index < negativeRange[0] || index > negativeRange[1])\n            && (index < positiveRange[0] || index > positiveRange[1])\n    )\n      return Number.MAX_SAFE_INTEGER;\n\n    if (loop) {\n      const inputRange = [\n        -TOTAL_WIDTH,\n        MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n        MIN - HALF_WIDTH - startPos,\n        0,\n        MAX + HALF_WIDTH - startPos,\n        MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n        TOTAL_WIDTH,\n      ];\n\n      const outputRange = [\n        startPos,\n        MAX + HALF_WIDTH - Number.MIN_VALUE,\n        MIN - HALF_WIDTH,\n        startPos,\n        MAX + HALF_WIDTH,\n        MIN - HALF_WIDTH + Number.MIN_VALUE,\n        startPos,\n      ];\n\n      return interpolate(\n        handlerOffset.value,\n        inputRange,\n        outputRange,\n        Extrapolate.CLAMP,\n      );\n    }\n\n    return handlerOffset.value + size * index;\n  }, [loop, dataLength, viewCount, type, size, visibleRanges]);\n\n  return x;\n};\n"]}