{"version":3,"sources":["computeNewIndexWhenDataChanges.ts"],"names":["omitZero","a","b","computeNewIndexWhenDataChanges","params","direction","_handlerOffset","handlerOffset","size","previousLength","currentLength","positionIndex","round","isPositive","Math","abs","parseInt","String","prevOffset","prevIndex","changedLength","changedOffset"],"mappings":"usBAAgBA,CAAAA,Q,iEAASC,C,CAAWC,C,CAAW,CAE7C,GAAID,CAAC,GAAK,CAAV,CACE,MAAO,EAAP,CAEF,MAAOC,CAAAA,CAAP,CACD,C,0yGAEeC,CAAAA,8B,kEAA+BC,M,CAM5C,CAED,GAAQC,CAAAA,SAAR,CAA0FD,MAA1F,CAAQC,SAAR,CAAkCC,cAAlC,CAA0FF,MAA1F,CAAmBG,aAAnB,CAAkDC,IAAlD,CAA0FJ,MAA1F,CAAkDI,IAAlD,CAAwDC,cAAxD,CAA0FL,MAA1F,CAAwDK,cAAxD,CAAwEC,aAAxE,CAA0FN,MAA1F,CAAwEM,aAAxE,CAEA,GAAIH,CAAAA,aAAa,CAAGD,cAApB,CACA,GAAIK,CAAAA,aAAJ,CACA,GAAIC,CAAAA,KAAJ,CAEA,GAAMC,CAAAA,UAAU,CAAGR,SAAS,CAAG,CAA/B,CAEA,GAAIQ,UAAJ,CAAgB,CACdF,aAAa,CAAIG,IAAI,CAACC,GAAL,CAASR,aAAT,CAAD,CAA4BC,IAA5C,CACAI,KAAK,CAAGI,QAAQ,CAACC,MAAM,CAACjB,QAAQ,CAACS,cAAD,CAAiBE,aAAa,CAAGF,cAAjC,CAAT,CAAP,CAAhB,CACD,CAHD,IAIK,CACHE,aAAa,CAAG,CAACG,IAAI,CAACC,GAAL,CAASR,aAAT,EAA0BC,IAA3B,EAAmCA,IAAnD,CACAI,KAAK,CAAGI,QAAQ,CAACC,MAAM,CAACjB,QAAQ,CAACS,cAAD,CAAiBE,aAAa,CAAGF,cAAjC,CAAT,CAAP,CAAR,CAA6E,CAArF,CACD,CAED,GAAMS,CAAAA,UAAU,CAAGlB,QAAQ,CAACS,cAAD,CAAiBE,aAAa,CAAGF,cAAjC,CAA3B,CACA,GAAMU,CAAAA,SAAS,CAAGN,UAAU,CAAGK,UAAH,CAAgBT,cAAc,CAAGS,UAAjB,CAA8B,CAA1E,CACA,GAAME,CAAAA,aAAa,CAAGR,KAAK,EAAIF,aAAa,CAAGD,cAApB,CAA3B,CACA,GAAMY,CAAAA,aAAa,CAAGD,aAAa,CAAGZ,IAAtC,CACA,GAAIW,SAAS,CAAGT,aAAa,CAAG,CAA5B,EAAiCA,aAAa,CAAGD,cAArD,CAAqE,CACnE,GAAII,UAAJ,CACEN,aAAa,CAAG,CAACG,aAAa,CAAG,CAAjB,EAAsBF,IAAtB,CAA6BH,SAA7C,CADF,IAIEE,CAAAA,aAAa,CAAG,CAACG,aAAa,CAAG,CAAjB,EAAsBF,IAAtB,CAA6B,CAAC,CAA9C,CACH,CAND,IAOK,CACHD,aAAa,EAAIc,aAAa,CAAGhB,SAAjC,CACD,CAED,MAAOE,CAAAA,aAAP,CACD,C,uBAxBoBP,Q","sourcesContent":["export function omitZero(a: number, b: number) {\n  \"worklet\";\n  if (a === 0)\n    return 0;\n\n  return b;\n}\n\nexport function computeNewIndexWhenDataChanges(params: {\n  direction: number\n  handlerOffset: number\n  size: number\n  previousLength: number\n  currentLength: number\n}) {\n  \"worklet\";\n  const { direction, handlerOffset: _handlerOffset, size, previousLength, currentLength } = params;\n\n  let handlerOffset = _handlerOffset;\n  let positionIndex;\n  let round;\n\n  const isPositive = direction < 0;\n\n  if (isPositive) {\n    positionIndex = (Math.abs(handlerOffset)) / size;\n    round = parseInt(String(omitZero(previousLength, positionIndex / previousLength)));\n  }\n  else {\n    positionIndex = (Math.abs(handlerOffset) - size) / size;\n    round = parseInt(String(omitZero(previousLength, positionIndex / previousLength))) + 1;\n  }\n\n  const prevOffset = omitZero(previousLength, positionIndex % previousLength);\n  const prevIndex = isPositive ? prevOffset : previousLength - prevOffset - 1;\n  const changedLength = round * (currentLength - previousLength);\n  const changedOffset = changedLength * size;\n  if (prevIndex > currentLength - 1 && currentLength < previousLength) {\n    if (isPositive)\n      handlerOffset = (currentLength - 1) * size * direction;\n\n    else\n      handlerOffset = (currentLength - 1) * size * -1;\n  }\n  else {\n    handlerOffset += changedOffset * direction;\n  }\n\n  return handlerOffset;\n}\n\n"]}